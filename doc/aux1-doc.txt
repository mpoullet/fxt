// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/aux1/arith1.h: ==========

inline void negate(Type *f, ulong n);
// negate every element of f[]

inline void multiply_val(Type *f, ulong n, Type s);
// f[] *= s

inline void add(Type *f, ulong n, const Type *g);
// f[] += g[] element-wise

inline void subtract(Type *f, ulong n, const Type *g);
// f[] -= g[] element-wise

inline void multiply(Type *f, ulong n, const Type *g);
//  f[] *= g[] element-wise

// ========== HEADER FILE src/aux1/bytescan.h: ==========

// ----- SRCFILE=src/aux1/bytescan.cc: -----
ulong long_strlen(const char *str);
// Return length of string starting at str.

// ========== HEADER FILE src/aux1/copy.h: ==========

inline void fill(Type *dst, ulong n, Type v);
// Fill array with value v

inline void null(Type *dst, ulong n);
// Set array to zero.

inline void acopy(const Type *src, Type *dst, ulong n);
// Copy array src[] to dst[]
// Named acopy() to avoid conflict with std::copy()

inline void copy_cyclic(const Type *src, Type *dst, ulong n, ulong s);
// Copy array src[] to dst[]
// starting from position s in src[]
// wrap around end of src[]  (src[n-1])
//
// src[] is assumed to be of length n
// dst[] must be of length n at least
//
// Equivalent to:  { acopy(src, dst, n); rotate_right(dst, n, s); }

inline void skip_copy(const Type *src, Type *dst, ulong n, ulong d);
// Copy n elements from src[] at positions
//   [0],[d],[2d],[3d],...,[(n-1)*d]
//   to dst[0, 1, ..., n-1]

inline void skip_copy_back(const Type *src, Type *dst, ulong n, ulong d);
// Copy n elements from src[0, 1, ..., n-1]
//   to dst[] at positions
//   [0],[d],[2d],[3d],...,[(n-1)*d]

inline void set_seq(Type *dst, ulong n, Type start=0);
// Fill array with sequence
//   start, start+1, start+1, ...

// ========== HEADER FILE src/aux1/num2str.h: ==========

// ----- SRCFILE=src/aux1/num2str.cc: -----
void num2str(ulong x, ulong rd, char *str);
// Write radix-rd representation of x to str[].
// Must have rd <= 36.

// ========== HEADER FILE src/aux1/wordgray.h: ==========


// Word-wise Gray code and reversed Gray code.
// cf. bits/graycode.h and bits/graypower.h

void word_gray(Type *f, ulong n);

void inverse_word_gray(Type *f, ulong n);

void word_gray_pow(Type *f, ulong n, ulong x);
// result is identical to
//   for (ulong k=0; k<x; ++k)  word_gray(f, n);
// Work <= n/2

void word_rev_gray(Type *f, ulong n);

void inverse_word_rev_gray(Type *f, ulong n);

void word_rev_gray_pow(Type *f, ulong n, ulong x);
// result is identical to
//   for (ulong k=0; k<x; ++k)  word_rev_gray(f, n);
// work <= n/2

