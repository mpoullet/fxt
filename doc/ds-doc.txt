// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/ds/array2d.h: ==========

class array2d;
// Two-dimensional array.

// ========== HEADER FILE src/ds/array3d.h: ==========

class array3d;
// Three-dimensional array.

// ========== HEADER FILE src/ds/bitarray.h: ==========

class bitarray;
// Bit-array class mostly for use as memory saving array of Boolean values.
// Valid index is 0...nb_-1 (as usual in C arrays).

// ========== HEADER FILE src/ds/bitarray2d.h: ==========

class bitarray2d;
// Two-dimensional bit-array.

// ========== HEADER FILE src/ds/bounding-box-3d.h: ==========

class bounding_box_3d;
// 3-dimensional bounding box that can grow to contain
// coordinates given in the update() method.

// ========== HEADER FILE src/ds/bounding-box.h: ==========

class bounding_box;
// 2-dimensional bounding box that can grow to contain
// coordinates given in the update() method.

// ========== HEADER FILE src/ds/centered-array2d.h: ==========

class centered_array2d;
// Centered 2-dimensional array from array2d<Type>,
// using point2d<long> or vector2d<long> for coordinates.
// Valid cells are in the range [ +-k , +-k ].

// ========== HEADER FILE src/ds/centered-array3d.h: ==========

class centered_array3d;
// Centered 2-dimensional array from array3d<Type>,
// using point3d<long> or vector3d<long> for coordinates.
// Valid cells are in the range [ +-k , +-k , +-k ].

// ========== HEADER FILE src/ds/deque.h: ==========

class deque;
// deque := double-ended queue
// Can grow dynamically

// ========== HEADER FILE src/ds/heap.h: ==========

ulong test_heap(const Type *x, ulong n);
// Return 0 if x[] has heap property
// else index of node found to be greater than its parent.

void heapify(Type *z, ulong n, ulong k);
// Subject to the condition that the trees below the children of node
// k are heaps, move the element z[k] (down) until the tree below node k is a heap.
// Data expected in z[1,2,...,n].

void build_heap(Type *x, ulong n);
// Reorder data to a heap.
// Data expected in x[0,1,...,n-1].

bool heap_insert(Type *x, ulong n, ulong s, Type t);
// With x[] a heap of current size n
// and max size s (i.e. space for s elements allocated),
// insert t and restore heap-property.
// Return true if successful, else (i.e. if space exhausted) false.
// Complexity is O(log(n)).

Type heap_extract_max(Type *x, ulong n);
// Return maximal element of heap and restore heap structure.
// Return value is undefined for 0==n.

// ========== HEADER FILE src/ds/left-right-array.h: ==========

class left_right_array;
// Maintain index array [0,...,n-1], keep track which index is set or free.
// Allows, in time O(log(n)), to
// - find k-th free index (where 0<=k<=num_free())
// - find k-th set index (where 0<=k<=num_set())
// - determine how many indices are free/set to the left/right of
//   an absolute index i (where 0<=i<n).

// ========== HEADER FILE src/ds/point2d.h: ==========

class point2d;
// Point in 2 dimensions with basic operations.

inline point2d<double> mid_point(const point2d<double> & P, const point2d<double> & Q);

inline point2d<float> mid_point(const point2d<float> & P, const point2d<float> & Q);

inline point2d<long double> mid_point(const point2d<long double> & P, const point2d<long double> & Q);

inline point2d<Type> mid_point(const point2d<Type> & P, const point2d<Type> & Q);

// ========== HEADER FILE src/ds/point3d.h: ==========

class point3d;
// Point in 3 dimensions with basic operations.

inline point3d<double> mid_point(const point3d<double> & P, const point3d<double> & Q);

inline point3d<float> mid_point(const point3d<float> & P, const point3d<float> & Q);

inline point3d<long double> mid_point(const point3d<long double> & P, const point3d<long double> & Q);

inline point3d<Type> mid_point(const point3d<Type> & P, const point3d<Type> & Q);

// ========== HEADER FILE src/ds/priorityqueue.h: ==========


#if  1
// next() is the one with the smallest key
// i.e.  extract_next()  is  extract_min()
#define _CMP_ <
#define _CMPEQ_ <=
#else
// next() is the one with the biggest key
// i.e.  extract_next()  is  extract_max()
#define _CMP_ >
#define _CMPEQ_ >=
#endif

class priority_queue;
// Priority queue.
// Can grow dynamically.

// ========== HEADER FILE src/ds/queue.h: ==========

class queue;
// Implementation of a queue

// ========== HEADER FILE src/ds/ringbuffer.h: ==========

class ringbuffer;
// Implementation of a ring buffer

// ========== HEADER FILE src/ds/stack.h: ==========

class stack;

// ========== HEADER FILE src/ds/vector2d.h: ==========

class vector2d;
// 2-dimensional vector with basic operations.

inline Type outer_z_left(const vector2d<Type> &V, const vector2d<Type> &W);
// Return z-coordinate of cross product for 3D vectors
// [V.x(), V.y(), 0] and [W.x(), W.y(), 0]
// for left handed coordinates.

inline Type outer_z_right(const vector2d<Type> &V, const vector2d<Type> &W);
// Return z-coordinate of cross product for 3D vectors
// [V.x(), V.y(), 0] and [W.x(), W.y(), 0]
// for right handed coordinates.

// ========== HEADER FILE src/ds/vector3d.h: ==========

class vector3d;
// 3-dimensional vector with basic operations.

inline vector3d<Type> outer_left(const vector3d<Type> &V, const vector3d<Type> &W);
// Return cross product for left handed coordinates.

inline vector3d<Type> outer_right(const vector3d<Type> &V, const vector3d<Type> &W);
// Return cross product for right handed coordinates.

